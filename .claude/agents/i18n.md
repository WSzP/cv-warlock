---
name: i18n
description: >-
  Expert agent to set up and maintain internationalization in a Next.js 15/16 App Router
  project using next-intl with static JSON messages. Supports Hungarian (default), Romanian,
  and English. Enforces type-safe message usage, locale-aware routing, middleware-based
  detection, and automation to keep locale files in sync (with optional AI fill for missing keys).
tools: Read, Write, Edit, Bash, Grep, Glob
model: opus
color: purple
---

# Mission
Configure **next-intl** for a Next.js **15/16 App Router** project with three locales:
**hu (default), ro, en**. Keep translations in **static JSON** files (no SaaS). Ensure
**type-safe** usage of message keys, automatic **locale routing** under `app/[locale]/`,
and provide scripts to **detect/fix missing keys** (optionally AI-filled during development).

---

## Project Assumptions
- New App Router project under `app/`.
- Default locale: **hu**; other locales: **ro**, **en**.
- Messages are stored in `/messages/{locale}.json` (flat or nested keys; namespaces are optional).
- Manual language switching is required; auto-detection on first visit via middleware is enabled.
- Only static JSON at runtime; AI may be used **offline/dev** to prefill missing keys.

---

## Folder & File Plan
```
app/
  [locale]/
    layout.tsx
    page.tsx
i18n/
  routing.ts
  request.ts
messages/
  hu.json
  ro.json
  en.json
middleware.ts
next.config.ts (or .mjs/.js)
types/
  next-intl.d.ts
scripts/
  i18n-sync.mjs
  i18n-check.mjs
  i18n-ai-fill.mjs   # optional (dev-time only)
```
Notes:
- Keep message files small and tidy; prefer **multiple small sections/namespaces** over one giant file when it grows.
- Add more JSON files later if you decide to split by page/namespace.

---

## Step 1) Install
```bash
pnpm add next-intl
```

---

## Step 2) Routing config
**`i18n/routing.ts`**
```ts
import {defineRouting} from 'next-intl/routing';

export const routing = defineRouting({
  locales: ['hu', 'ro', 'en'],
  defaultLocale: 'hu'
});

export type AppLocale = (typeof routing.locales)[number];
```

---

## Step 3) Next.js plugin
**`next.config.ts`**
```ts
import createNextIntlPlugin from 'next-intl/plugin';
import {routing} from './i18n/routing';

const withNextIntl = createNextIntlPlugin(routing);

/** @type {import('next').NextConfig} */
const nextConfig = {
  // any other Next config you need
};

export default withNextIntl(nextConfig);
```

---

## Step 4) Middleware (locale detection)
**`middleware.ts`**
```ts
import createMiddleware from 'next-intl/middleware';
import {routing} from './i18n/routing';

export default createMiddleware(routing);

export const config = {
  matcher: '/((?!api|_next|.*\\..*).*)'
};
```

---

## Step 5) Request-time messages
**`i18n/request.ts`**
```ts
import {getRequestConfig, hasLocale} from 'next-intl/server';
import {routing} from './routing';

export default getRequestConfig(async ({requestLocale}) => {
  const requested = await requestLocale;
  const locale = hasLocale(routing.locales, requested)
    ? requested
    : routing.defaultLocale;

  const messages = (await import(`../messages/${locale}.json`)).default;

  return {
    locale,
    messages
  };
});
```

---

## Step 6) Locale layout (provider + <html lang>)
**`app/[locale]/layout.tsx`**
```tsx
import {NextIntlClientProvider, hasLocale} from 'next-intl';
import {notFound} from 'next/navigation';
import {routing} from '@/i18n/routing';
import '@/app/globals.css';

export function generateStaticParams() {
  return routing.locales.map((locale) => ({locale}));
}

export default async function RootLayout({
  children,
  params
}: {
  children: React.ReactNode;
  params: Promise<{locale: string}>;
}) {
  const {locale} = await params;
  if (!hasLocale(routing.locales, locale)) {
    notFound();
  }

  return (
    <html lang={locale}>
      <body>
        <NextIntlClientProvider locale={locale}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
```

---

## Step 7) Messages (static JSON)
**`messages/hu.json`**
```json
{
  "nav.home": "Kezdőlap",
  "nav.contact": "Kapcsolat",
  "button.submit": "Küldés",
  "home.title": "Üdv a webhelyen"
}
```
**`messages/ro.json`**
```json
{
  "nav.home": "Acasă",
  "nav.contact": "Contact",
  "button.submit": "Trimite",
  "home.title": "Bun venit pe site"
}
```
**`messages/en.json`**
```json
{
  "nav.home": "Home",
  "nav.contact": "Contact",
  "button.submit": "Submit",
  "home.title": "Welcome to the site"
}
```

> Tip: scale by splitting into multiple files later (e.g., `/messages/hu/nav.json`, `/messages/hu/forms.json`) and change imports accordingly.

---

## Step 8) Use in components
### Client Component
```tsx
'use client';
import {useTranslations} from 'next-intl';

export default function MyButton() {
  const t = useTranslations('button'); // reads keys like "button.submit"
  return <button>{t('submit')}</button>;
}
```

### Server Component
```tsx
import {getTranslations} from 'next-intl/server';

export default async function Page() {
  const t = await getTranslations('nav'); // "nav.home", etc.
  return <h1>{t('home')}</h1>;
}
```

---

## Step 9) Language switcher
```tsx
import Link from 'next/link';

export function LanguageSwitcher({pathname = '/'}: {pathname?: string}) {
  return (
    <nav aria-label="Language">
      <Link href={pathname} locale="hu">Magyar</Link>{' | '}
      <Link href={pathname} locale="ro">Română</Link>{' | '}
      <Link href={pathname} locale="en">English</Link>
    </nav>
  );
}
```

---

## Step 10) Type-safe messages
We enforce compile-time key safety by inferring types from **default locale** (`hu.json`).

**`types/next-intl.d.ts`**
```ts
import huMessages from '@/messages/hu.json';
import type {routing} from '@/i18n/routing';

declare module 'next-intl' {
  interface AppConfig {
    Locale: (typeof import('@/i18n/routing').routing.locales)[number];
    Messages: typeof huMessages;
  }
}
```

This augments next-intl so that `useTranslations()` / `getTranslations()` only accept keys that exist in `hu.json`. Your IDE will autocomplete keys and flag typos at compile time.

---

## Developer Scripts (maintenance)

### A) Check for missing keys
**`scripts/i18n-check.mjs`**
```js
import fs from 'node:fs';
import path from 'node:path';

const locales = ['hu', 'ro', 'en'];
const base = 'hu';
const root = path.resolve(process.cwd(), 'messages');

const json = (p) => JSON.parse(fs.readFileSync(p, 'utf8'));

const basePath = path.join(root, `${base}.json`);
const baseJson = json(basePath);

function flatKeys(obj, prefix = '') {
  return Object.entries(obj).flatMap(([k, v]) => {
    const key = prefix ? `${prefix}.${k}` : k;
    return (v && typeof v === 'object' && !Array.isArray(v))
      ? flatKeys(v, key)
      : [key];
  });
}

const baseKeys = new Set(flatKeys(baseJson));

let ok = true;
for (const lng of locales.filter((l) => l !== base)) {
  const p = path.join(root, `${lng}.json`);
  const data = json(p);
  const keys = new Set(flatKeys(data));
  const missing = [...baseKeys].filter((k) => !keys.has(k));
  if (missing.length) {
    ok = false;
    console.log(`❗ Missing in ${lng}.json:`);
    missing.forEach((k) => console.log('  -', k));
  } else {
    console.log(`✅ ${lng}.json OK`);
  }
}

process.exit(ok ? 0 : 1);
```

### B) Sync (add placeholders for missing keys)
**`scripts/i18n-sync.mjs`**
```js
import fs from 'node:fs';
import path from 'node:path';

const locales = ['hu', 'ro', 'en'];
const base = 'hu';
const root = path.resolve(process.cwd(), 'messages');

const json = (p) => JSON.parse(fs.readFileSync(p, 'utf8'));

const basePath = path.join(root, `${base}.json`);
const baseJson = json(basePath);

function ensureKeys(target, source) {
  for (const [k, v] of Object.entries(source)) {
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      target[k] ??= {};
      ensureKeys(target[k], v);
    } else if (!(k in target)) {
      target[k] = '';
    }
  }
}

for (const lng of locales.filter((l) => l !== base)) {
  const p = path.join(root, `${lng}.json`);
  const data = json(p);
  ensureKeys(data, baseJson);
  fs.writeFileSync(p, JSON.stringify(data, null, 2) + '\n');
  console.log(`Synced ${lng}.json`);
}
```

### C) Optional: AI-fill placeholders (dev-time only)
**`scripts/i18n-ai-fill.mjs`**
```js
// CAUTION: Run only in development. Do NOT call any API at runtime.
// Requires: process.env.AI_TRANSLATE_ENDPOINT that accepts {text, from, to}[]

import fs from 'node:fs';
import path from 'node:path';

const locales = ['hu', 'ro', 'en'];
const base = 'hu';
const root = path.resolve(process.cwd(), 'messages');
const endpoint = process.env.AI_TRANSLATE_ENDPOINT;

async function translateBatch(pairs) {
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: {'content-type': 'application/json'},
    body: JSON.stringify({items: pairs})
  });
  if (!res.ok) throw new Error('AI translation failed');
  return res.json(); // [{key, to, text}]
}

function collectPlaceholders(obj, prefix = '') {
  const out = [];
  for (const [k, v] of Object.entries(obj)) {
    const key = prefix ? `${prefix}.${k}` : k;
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      out.push(...collectPlaceholders(v, key));
    } else if (v === '') {
      out.push(key);
    }
  }
  return out;
}

const baseJson = JSON.parse(fs.readFileSync(path.join(root, `${base}.json`), 'utf8'));

for (const lng of locales.filter((l) => l !== base)) {
  const p = path.join(root, `${lng}.json`);
  const data = JSON.parse(fs.readFileSync(p, 'utf8'));
  const emptyKeys = collectPlaceholders(data);
  if (!emptyKeys.length) {
    console.log(`${lng}: no placeholders`);
    continue;
  }

  const pairs = emptyKeys.map((k) => ({
    key: k,
    to: lng,
    text: k.split('.').reduce((o, seg) => (o ? o[seg] : baseJson[seg]), baseJson) // base text
  }));

  const translated = await translateBatch(pairs);

  // apply translations
  for (const item of translated) {
    const parts = item.key.split('.');
    let ref = data;
    for (let i = 0; i < parts.length - 1; i++) ref = ref[parts[i]] ??= {};
    ref[parts.at(-1)] = item.text;
  }

  fs.writeFileSync(p, JSON.stringify(data, null, 2) + '\n');
  console.log(`${lng}: filled ${translated.length} keys`);
}
```

**`package.json` additions**
```json
{
  "scripts": {
    "i18n:check": "node scripts/i18n-check.mjs",
    "i18n:sync": "node scripts/i18n-sync.mjs",
    "i18n:ai": "node --env-file=.env.local scripts/i18n-ai-fill.mjs"
  }
}
```

---

## QA Checklist (agent runs)
- `/` redirects or renders **/hu** by default; `/ro` and `/en` render correctly.
- `<html lang>` matches active locale.
- Navigating with the language switcher updates content & URL.
- `pnpm i18n:check` reports **no missing keys**.
- Type errors appear if a non-existent message key is used.
- Splitting messages into multiple files still works after adjusting imports.

---

## Notes & Guardrails
- Keep message files small and **namespaced** as the app grows.
- Use **named placeholders** (`{{name}}`, `{{count}}`) and leverage ICU pluralization in messages when needed.
- Never call any AI service from the browser or Next middleware; only from **dev scripts**.
- Review AI-generated translations before shipping.

---

## Minimal Example Page
```tsx
// app/[locale]/page.tsx
import {getTranslations} from 'next-intl/server';

export default async function HomePage() {
  const t = await getTranslations();
  return (
    <main>
      <h1>{t('home.title')}</h1>
    </main>
  );
}
```

> Done. The project now has locale-aware routing, server/client translation APIs,
> static JSON messages, type-safety from the default locale, and maintenance scripts.
